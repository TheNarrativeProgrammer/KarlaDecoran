<!DOCTYPE html>
<html lang="en"><head>
    <title>karlas webpage</title>
    <link rel="stylesheet" href="style.css">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>

    


    <body>
        <!--HEADER-->
        <div class="Header-Container-lvl2-title">
            <!--<h1 id="Header-font-container-lvl4">KARLA DECORAN</h1>-->
        </div>

        <div class="main-nav">
            <ul class="nav">
                <li class="name">Karla Decoran - Digital Designer // Artist</li>
                <li>
                    <a href="index.html">Home</a> -
                    <a href="#portfolio">Portfolio</a> -
                    <a href="#bio">About</a> -
                    <a href="#contact">Contact</a>
                </li>
            </ul>
        </div>

        <section id="intro">
            <div style="padding: 20px;">
                <img src="images/KarlaProfilePic.jpg" id="bioPic">
            </div>
            
            <!--Opening Paragraph and links-->
            <div class="Paragraph-Container">
                <p>
                    Hi, I'm <span id="large_font_pink"><a href="#bio"> Karla</a></span>.
                    I'm an <span id="large_font_blue"><a href="Art.html"> artist</a></span> and a
                    <span id="large_font_green"><a href="Design.html"> UX/UI designer</a></span>
                </p>
            </div>
        </section>

        <!--Sidebar-->
        <!--<div class="UI-Container-lvl1-all">

            <aside class="UI-sidebar-lvl1">
                <section class="UI-LinksSection-lvl2">
                    <ul>
                        <li><a href="index.html">Home</a></li>
                        <li><a href="Bio.html">About</a></li>
                        <li><a href="Design.html">Design</a></li>
                        <li><a href="Art.html">Art</a></li>
                    </ul>
                </section>
            </aside>
        </div>-->

        <section id="portfolio">

            <h2>Portfolio</h2>

            <div class="projects-container">
                <div class="project full-width">

                    <h3>Purrfect Match</h3>

                    <div class="project-desktop-wrapper">
                        <div class="left-column">
                            <div class="video-container">
                                <video class="autoplay-video" muted loop playsinline preload="auto">
                                    <source src="videos/PurrfectMatchTrailerNoFadeIn.mp4" type="video/mp4">
                                </video>
                            </div>

                            <p>
                                <!--<button onclick="window.location.href='FrogsAndFreedom.html'">Code Walkthrough</button>-->
                                <a href="FrogsAndFreedom.html" class="Button Button-large">
                                    <svg class="Button-svg" viewBox="0 0 360 96">
                                        <rect class="Button-line Button-line--outer" width="360" height="96" rx="8" ry="8" />
                                        <rect class="Button-line Button-line--inner" width="360" height="96" rx="8" ry="8" />
                                    </svg>
                                    <span class="Button-content">UX/UI Walkthrough</span>
                                </a>
                            </p>
                        </div>

                        <div class="right-column">
                            <h4>Title, Dates, Software</h4>
                            <ul>
                                <li>UX/UI Designer</li>
                                <li>Oct 2025</li>
                                <li>Unreal // Figma</li>
                            </ul>

                            <h4>Links</h4>
                            <ul>
                                <li><a href="https://reidgillis.itch.io/purrfect-match-game" target="_blank" rel="noopener noreferrer">Itch</a></li>

                            </ul>

                            <h4>Role Summary</h4>
                            <ul>
                                <li>Created UI assests for displaying info and clickable elements.</li>
                                <li>Developed UX flow diagram detailing game progression.</li>
                                <li>Iterated on design to solve problems identified during play testing.</li>
                            </ul>

                        </div>

                    </div>
                </div>
            </div>




            <div class="projects-container">
                <div class="project full-width">

                    <h3>Art</h3>

                    <div class="project-desktop-wrapper">
                        <div class="left-column">
                            <div class="video-container">
                                <video class="autoplay-video" muted loop playsinline preload="auto">
                                    <source src="videos/KarlaArtVideo.mp4" type="video/mp4">
                                </video>
                            </div>

                            <p>
                                <!--<button onclick="window.location.href='FrogsAndFreedom.html'">Code Walkthrough</button>-->
                                <a href="Art.html" class="Button Button-large">
                                    <svg class="Button-svg" viewBox="0 0 360 96">
                                        <rect class="Button-line Button-line--outer" width="360" height="96" rx="8" ry="8" />
                                        <rect class="Button-line Button-line--inner" width="360" height="96" rx="8" ry="8" />
                                    </svg>
                                    <span class="Button-content">Art Portfolio</span>
                                </a>
                            </p>
                        </div>

                        <div class="right-column">
                            <h4>Title, Dates, Software</h4>
                            <ul>
                                <li>UX/UI Designer</li>
                                <li>Oct 2025</li>
                                <li>Unreal // Figma</li>
                            </ul>

                            <h4>Links</h4>
                            <ul>
                                <li><a href="https://reidgillis.itch.io/purrfect-match-game" target="_blank" rel="noopener noreferrer">Itch</a></li>

                            </ul>

                            <h4>Role Summary</h4>
                            <ul>
                                <li>Created UI assests for displaying info and clickable elements.</li>
                                <li>Developed UX flow diagram detailing game progression.</li>
                                <li>Iterated on design to solve problems identified during play testing.</li>
                            </ul>

                        </div>

                    </div>
                </div>
            </div>





            <div class="projects-container">

                <div class="project full-width">
                    <div class="media-container">
                        <!--<h3>Attack Tokens</h3>-->
                        <h2>3</h2>
                        <div class="image-container">
                            <button class="prev btn-type-2">&#10094;</button>
                            <div class="carousel-track">
                                <div class="carousel-slide"><img src="Images/Frogs/Tokens_Giver_HeaderAndTokenData_Img1.png" alt=""></div>
                                <div class="carousel-slide"><img src="Images/Frogs/Tokens_Giver_InitializeComponent_Img2.gif" alt=""></div>
                                <div class="carousel-slide"><img src="Images/Frogs/Tokens_Giver_SetUpAttachments_Img3.png" alt=""></div>
                                <div class="carousel-slide"><img src="Images/Frogs/Tokens_Giver_GiverInterfaceAndImplementation_Img4.png" alt=""></div>
                                <div class="carousel-slide"><img src="Images/Frogs/Tokens_Requester_HeaderAndData_Img5.png" alt=""></div>
                                <div class="carousel-slide"><img src="Images/Frogs/Tokens_Requester_InterfaceImplementation_Img6.png" alt=""></div>
                                <div class="carousel-slide"><img src="Images/Frogs/Token_Requester_BTTHasAttackToken_HasAttackToken_Img7.png" alt=""></div>
                                <div class="carousel-slide"><img src="Images/Frogs/Token_Requester_BTTHasAttackToken_RequestAttackToken_Img8.png" alt=""></div>
                                <div class="carousel-slide"><img src="Images/Frogs/Token_Requester_BTTHasAttackToken_RequestAttackToken_HandleReserveTokenRequest_Img9.png" alt=""></div>
                                <div class="carousel-slide"><img src="Images/Frogs/Token_Requester_BTTHasAttackToken_RequestAttackToken_ReserveAttackAndStoreInMap_Img10.png" alt=""></div>
                                <div class="carousel-slide"><img src="Images/Frogs/Token_ReturnTokensPerceptionForgotten_img11.png" alt=""></div>
                                <div class="carousel-slide"><img src="Images/Frogs/Token_ReturnTokensPerceptionForgotten_ReturnTokens_img12.png" alt=""></div>
                                <div class="carousel-slide"><img src="Images/Frogs/Token_ReturnTokensAttackFinished_img13.png" alt=""></div>
                                <div class="carousel-slide"><img src="Images/Frogs/Token_ReturnTokensAttackFinished_img14.png" alt=""></div>
                            </div>
                            <button class="next btn-type-2">&#10095;</button>
                        </div>

                        <div class="codeDescription-container">
                            <p data-slide="0">
                                1. The Attack Token system consists of two core components: AttackTokenGiverComponent and AttackTokenRequesterComponent.

                                <br></br> The GiverComponent is attached to any actor that can be attacked — typically ACharacterBasePlayer or AGenerator — and is responsible for distributing attack tokens.

                                <br></br> Enemy classes that require a token to engage (such as Flushers and Pinners) use the RequesterComponent to request and return tokens.


                            </p>

                            <p data-slide="1">
                                2. To prevent enemy overlap during combat, six USceneComponent endpoints are positioned in front of each actor with an AttackTokenGiverComponent. These points define valid attack locations.

                                <br></br> _mTotalAttackTokensFlusher and _mTotalAttackTokensPinner specify how many tokens each enemy type may occupy per endpoint.

                                <br></br> The setup function SetUpAttachments() initializes and populates the _mmTokenDataAttackLocations map with these scene component references, forming the foundation for all future attack token allocation.
                            </p>

                            <p data-slide="2">
                                3. SetUpAttachments() creates six keyed entries in _mmTokenDataAttackLocations: indices 0–2 for Flushers and 3–5 for Pinners.

                                <br></br>AddAttackLocationToMap() then iterates over temporary arrays of these scene components, constructing a new FGiverAttackTokenData for each and setting its initial token capacity and availability.


                                <br></br> This ensures every attack slot is defined, type-limited, and ready for runtime token assignment.
                            </p>

                            <p data-slide="3">
                                4. An interface complements the AttackTokenGiverComponent, enabling enemies to request and return tokens or query valid attack locations without direct coupling.

                                <br></br>ACharacterBasePlayer implements this interface, using its helper functions to call the GiverComponent’s internal logic directly.
                                This interface-driven design ensures clean, modular communication between requesters and their attack targets.
                            </p>

                            <p data-slide="4">
                                5. The AttackTokenRequesterComponent is attached to both Flusher and Pinner enemies. Each type has its own maRequestedTokenIndex array, defining which attack endpoints (0–2 or 3–5) it may use.

                                <br></br>The component also maintains a map _mmTakenAttackTokens, keyed by the attack target AActor, storing an FRequesterGeneralTokenData struct with all tokens the requester currently holds.
                            </p>

                            <p data-slide="5">
                                6.The RequesterComponent includes its own interface, used by both the Behavior Tree’s Blackboard tasks and the attack targets themselves.

                                <br></br> This interface standardizes token request, reservation, and return workflows, streamlining AI communication during combat sequences.
                            </p>

                            <p data-slide="6">
                                7. When an enemy successfully detects the player via sight, its Blackboard transitions to the Attack state.
                                The Behavior Tree task BTT_RequestAttackToken first checks whether the AI already holds a token for its current attack target. If not, it issues a new token request.

                                <br></br> If the request succeeds (or the AI already possesses a token), FinishExecute returns success, enabling the attack sequence.

                                <br></br> Otherwise, the task fails, and the tree reverts to its default behavior until the cooldown decorator permits another request attempt.
                            </p>

                            <p data-slide="7">
                                8. FRequesterGeneralTokenData represents each requester’s stored token data within _mmTakenAttackTokens.

                                <br></br>When a request is made, HandleReserveTokenRequest() processes the attempt and returns a success flag.

                                <br></br> GetSenseIDofSenseAsEnum(), checks if the AI has sight perception info on the player character.

                                <br></br>If successful, IsTokenRequestSuccessful() updates the requester’s FRequesterReservation struct with the new token’s index and attack location.
                                <br></br>The updated reservation is then saved back into _mmTakenAttackTokens via ReserveAttackTokenAndStoreInMap(), synchronizing local and giver-side data.
                            </p>

                            <p data-slide="8">
                                9. The attack target’s interface function HandleReserveTokenRequest() delegates to the GiverComponent’s internal method of the same name.

                                <br></br>Flushers request attack indices 0–2, while Pinners use 3–5. Validation ensures team members never request invalid indices.

                                <br></br> Each FGiverAttackTokenData entry stores a dereferenced pointer to its map data, allowing direct modification.

                                <br></br>The Giver iterates through available slots, confirming capacity and token count.
                                If tokens are available, both the Giver’s map and the Requester’s reservation data are updated, returning true on success or false if the request fails.
                            </p>

                            <p data-slide="9">
                                10. Once a request succeeds, ReserveAttackTokenAndStoreInMap() records the AttackTarget, IndexOfReservationPoint, and LocationOfReservedPoint within _mmTakenAttackTokens.

                                <br></br> The function either retrieves or creates a new entry for the AttackTarget, ensuring all token data is consistent.

                                <br></br> RequestAttackToken() then returns a boolean result to the Behavior Tree task, which finishes execution based on whether the token was successfully reserved.
                            </p>

                            <p data-slide="10">
                                11. Tokens are returned either when an enemy completes its attack or when perception of the target becomes stale.

                                <br></br> GetLastStimulus() checks whether the AI still perceives the player before clearing its state.
                                For instance, if an enemy switches perception from the Generator to the Player mid-attack, it retains the token until all valid perception ends.

                                <br></br> When perception fully fades, the AI resets its state to Passive, clears its target reference, and calls ReturnAllAttackTokensForAllTarget(), which iterates through all owned tokens and returns them to their respective givers.
                            </p>

                            <p data-slide="11">
                                12. ReturnAttackTokens() retrieves the relevant FRequesterGeneralTokenData reference tied to the AttackTarget.

                                <br></br> It then calls HandleReturningToken() on the target actor, specifying the index and quantity to return. The Giver’s map is updated accordingly.

                                <br></br> Finally, the requester removes that token entry from its _mmTakenAttackTokens map, ensuring data integrity on both sides.
                            </p>

                            <p data-slide="12">
                                13. Tokens are also returned when an enemy finishes its attack sequence.

                                <br></br> BTT_AttackFlusher calls AttackBehaviour() — an IFrogAIable interface function implemented at the child-class level — which in turn executes the enemy’s specific Attack() logic.

                                <br></br> Once the attack concludes, the AI automatically returns its tokens before signaling completion through the appropriate delegate.
                            </p>

                            <p data-slide="13">
                                14. After a Flusher successfully reaches its reserved attack location, it immediately returns its tokens via ReturnAttackTokens().

                                <br></br> It then broadcasts AttackBehaviourFinishedDelegate to inform the Behavior Tree that the attack cycle is complete.


                            </p>
                        </div>
                    </div>
                </div>
            </div>
        </section>








                <section id="Art">
                    <h2>1</h2>
                    <div class="projects-container">
                        <div class="project max-width">
                            <h4>2</h4>
                            <div class="media-container">
                                <!--<h3>Attack Tokens</h3>-->
                                
                                <div class="image-container">
                                    <button class="prev btn-type-2">&#10094;</button>
                                    <div class="carousel-track">
                                        <div class="carousel-slide"><img src="Images/Frogs/Tokens_Giver_HeaderAndTokenData_Img1.png" alt=""></div>
                                        <div class="carousel-slide"><img src="Images/Frogs/Tokens_Giver_InitializeComponent_Img2.gif" alt=""></div>
                                        <div class="carousel-slide"><img src="Images/Frogs/Tokens_Giver_SetUpAttachments_Img3.png" alt=""></div>
                                        <div class="carousel-slide"><img src="Images/Frogs/Tokens_Giver_GiverInterfaceAndImplementation_Img4.png" alt=""></div>
                                        <div class="carousel-slide"><img src="Images/Frogs/Tokens_Requester_HeaderAndData_Img5.png" alt=""></div>
                                        <div class="carousel-slide"><img src="Images/Frogs/Tokens_Requester_InterfaceImplementation_Img6.png" alt=""></div>
                                        <div class="carousel-slide"><img src="Images/Frogs/Token_Requester_BTTHasAttackToken_HasAttackToken_Img7.png" alt=""></div>
                                        <div class="carousel-slide"><img src="Images/Frogs/Token_Requester_BTTHasAttackToken_RequestAttackToken_Img8.png" alt=""></div>
                                        <div class="carousel-slide"><img src="Images/Frogs/Token_Requester_BTTHasAttackToken_RequestAttackToken_HandleReserveTokenRequest_Img9.png" alt=""></div>
                                        <div class="carousel-slide"><img src="Images/Frogs/Token_Requester_BTTHasAttackToken_RequestAttackToken_ReserveAttackAndStoreInMap_Img10.png" alt=""></div>
                                        <div class="carousel-slide"><img src="Images/Frogs/Token_ReturnTokensPerceptionForgotten_img11.png" alt=""></div>
                                        <div class="carousel-slide"><img src="Images/Frogs/Token_ReturnTokensPerceptionForgotten_ReturnTokens_img12.png" alt=""></div>
                                        <div class="carousel-slide"><img src="Images/Frogs/Token_ReturnTokensAttackFinished_img13.png" alt=""></div>
                                        <div class="carousel-slide"><img src="Images/Frogs/Token_ReturnTokensAttackFinished_img14.png" alt=""></div>
                                    </div>
                                    <button class="next btn-type-2">&#10095;</button>
                                </div>

                                <div class="codeDescription-container">
                                    <p data-slide="0">
                                        1. The Attack Token system consists of two core components: AttackTokenGiverComponent and AttackTokenRequesterComponent.

                                        <br></br> The GiverComponent is attached to any actor that can be attacked — typically ACharacterBasePlayer or AGenerator — and is responsible for distributing attack tokens.

                                        <br></br> Enemy classes that require a token to engage (such as Flushers and Pinners) use the RequesterComponent to request and return tokens.


                                    </p>

                                    <p data-slide="1">
                                        2. To prevent enemy overlap during combat, six USceneComponent endpoints are positioned in front of each actor with an AttackTokenGiverComponent. These points define valid attack locations.

                                        <br></br> _mTotalAttackTokensFlusher and _mTotalAttackTokensPinner specify how many tokens each enemy type may occupy per endpoint.

                                        <br></br> The setup function SetUpAttachments() initializes and populates the _mmTokenDataAttackLocations map with these scene component references, forming the foundation for all future attack token allocation.
                                    </p>

                                    <p data-slide="2">
                                        3. SetUpAttachments() creates six keyed entries in _mmTokenDataAttackLocations: indices 0–2 for Flushers and 3–5 for Pinners.

                                        <br></br>AddAttackLocationToMap() then iterates over temporary arrays of these scene components, constructing a new FGiverAttackTokenData for each and setting its initial token capacity and availability.


                                        <br></br> This ensures every attack slot is defined, type-limited, and ready for runtime token assignment.
                                    </p>

                                    <p data-slide="3">
                                        4. An interface complements the AttackTokenGiverComponent, enabling enemies to request and return tokens or query valid attack locations without direct coupling.

                                        <br></br>ACharacterBasePlayer implements this interface, using its helper functions to call the GiverComponent’s internal logic directly.
                                        This interface-driven design ensures clean, modular communication between requesters and their attack targets.
                                    </p>

                                    <p data-slide="4">
                                        5. The AttackTokenRequesterComponent is attached to both Flusher and Pinner enemies. Each type has its own maRequestedTokenIndex array, defining which attack endpoints (0–2 or 3–5) it may use.

                                        <br></br>The component also maintains a map _mmTakenAttackTokens, keyed by the attack target AActor, storing an FRequesterGeneralTokenData struct with all tokens the requester currently holds.
                                    </p>

                                    <p data-slide="5">
                                        6.The RequesterComponent includes its own interface, used by both the Behavior Tree’s Blackboard tasks and the attack targets themselves.

                                        <br></br> This interface standardizes token request, reservation, and return workflows, streamlining AI communication during combat sequences.
                                    </p>

                                    <p data-slide="6">
                                        7. When an enemy successfully detects the player via sight, its Blackboard transitions to the Attack state.
                                        The Behavior Tree task BTT_RequestAttackToken first checks whether the AI already holds a token for its current attack target. If not, it issues a new token request.

                                        <br></br> If the request succeeds (or the AI already possesses a token), FinishExecute returns success, enabling the attack sequence.

                                        <br></br> Otherwise, the task fails, and the tree reverts to its default behavior until the cooldown decorator permits another request attempt.
                                    </p>

                                    <p data-slide="7">
                                        8. FRequesterGeneralTokenData represents each requester’s stored token data within _mmTakenAttackTokens.

                                        <br></br>When a request is made, HandleReserveTokenRequest() processes the attempt and returns a success flag.

                                        <br></br> GetSenseIDofSenseAsEnum(), checks if the AI has sight perception info on the player character.

                                        <br></br>If successful, IsTokenRequestSuccessful() updates the requester’s FRequesterReservation struct with the new token’s index and attack location.
                                        <br></br>The updated reservation is then saved back into _mmTakenAttackTokens via ReserveAttackTokenAndStoreInMap(), synchronizing local and giver-side data.
                                    </p>

                                    <p data-slide="8">
                                        9. The attack target’s interface function HandleReserveTokenRequest() delegates to the GiverComponent’s internal method of the same name.

                                        <br></br>Flushers request attack indices 0–2, while Pinners use 3–5. Validation ensures team members never request invalid indices.

                                        <br></br> Each FGiverAttackTokenData entry stores a dereferenced pointer to its map data, allowing direct modification.

                                        <br></br>The Giver iterates through available slots, confirming capacity and token count.
                                        If tokens are available, both the Giver’s map and the Requester’s reservation data are updated, returning true on success or false if the request fails.
                                    </p>

                                    <p data-slide="9">
                                        10. Once a request succeeds, ReserveAttackTokenAndStoreInMap() records the AttackTarget, IndexOfReservationPoint, and LocationOfReservedPoint within _mmTakenAttackTokens.

                                        <br></br> The function either retrieves or creates a new entry for the AttackTarget, ensuring all token data is consistent.

                                        <br></br> RequestAttackToken() then returns a boolean result to the Behavior Tree task, which finishes execution based on whether the token was successfully reserved.
                                    </p>

                                    <p data-slide="10">
                                        11. Tokens are returned either when an enemy completes its attack or when perception of the target becomes stale.

                                        <br></br> GetLastStimulus() checks whether the AI still perceives the player before clearing its state.
                                        For instance, if an enemy switches perception from the Generator to the Player mid-attack, it retains the token until all valid perception ends.

                                        <br></br> When perception fully fades, the AI resets its state to Passive, clears its target reference, and calls ReturnAllAttackTokensForAllTarget(), which iterates through all owned tokens and returns them to their respective givers.
                                    </p>

                                    <p data-slide="11">
                                        12. ReturnAttackTokens() retrieves the relevant FRequesterGeneralTokenData reference tied to the AttackTarget.

                                        <br></br> It then calls HandleReturningToken() on the target actor, specifying the index and quantity to return. The Giver’s map is updated accordingly.

                                        <br></br> Finally, the requester removes that token entry from its _mmTakenAttackTokens map, ensuring data integrity on both sides.
                                    </p>

                                    <p data-slide="12">
                                        13. Tokens are also returned when an enemy finishes its attack sequence.

                                        <br></br> BTT_AttackFlusher calls AttackBehaviour() — an IFrogAIable interface function implemented at the child-class level — which in turn executes the enemy’s specific Attack() logic.

                                        <br></br> Once the attack concludes, the AI automatically returns its tokens before signaling completion through the appropriate delegate.
                                    </p>

                                    <p data-slide="13">
                                        14. After a Flusher successfully reaches its reserved attack location, it immediately returns its tokens via ReturnAttackTokens().

                                        <br></br> It then broadcasts AttackBehaviourFinishedDelegate to inform the Behavior Tree that the attack cycle is complete.

                                        <br></br> The AI subsequently despawns and returns to the object pool, ready for reuse in future encounters.
                                    </p>
                                </div>
                            </div>


                            <h4></h4>
                            <h4>Tech </h4>
                            <div class="tech-skill">
                                <div class="tech-box">Components</div>
                                <div class="tech-box">Interfaces</div>
                            </div>

                        </div>
                    </div>
                </section>





                <!--<div class="ImageSideBySide">-->
                    <!--Container - houses 2 sub cointainers for imge/title/artile NOTE: article was taken out for this project, but div was kept in for future use and modularity. -->

                    <!--<div class="Content-Container-karla">-->
                        <!--Container - Image/article/tile-->
                        <!--<div id="Content-Container-lvl6-Img">-->
                            <!--Container - Image/Title-->
                            <!--<a href="anatomy.html"><img src="Images/Lungs.png" style="width: 30vw; height: 35vw"></a>--><!--Image and link sub page-->
                            <!--<h2>Anatomy</h2>--><!--Title of sub page-->
                        <!--</div>
                    </div>

                    <div class="Content-Container-karla">-->
                        <!--Container - Image/article/tile-->
                        <!--<div id="Content-Container-lvl6-Img">
                            <a href="collage.html"><img src="Images/Drawing11.png" style="width: 30vw; height: 35vw"></a>--><!--Image and link sub page-->
                            <!--<h2>Collage</h2>--><!--Title of sub page-->
                        <!--</div>
                    </div>
                </div>


                <div class="ImageSideBySide">

                    <div class="Content-Container-karla">-->
                        <!--Container - Image/article/tile-->
                        <!--<div id="Content-Container-lvl6-Img">-->
                            <!--Container - Image/Title-->
                            <!--<a href="Design.html"><img src="Images/Breathe.png" style="width: 30vw; height: 35vw"></a>
                            <h2>Design</h2>
                        </div>
                    </div>

                    <div class="Content-Container-karla">-->
                        <!--Container - Image/article/tile-->
                        <!--<div id="Content-Container-lvl6-Img">-->
                            <!--Container - Image/Title-->
                            <!--<a href="Ink.html"><img src="Images/floralwoman.jpg" style="width: 30vw; height: 35vw"></a>
                            <h2>Ink</h2>
                        </div>
                    </div>
                </div>



                <div class="ImageSideBySide">

                    <div class="Content-Container-karla">-->
                        <!--Container - Image/article/tile-->
                        <!--<div id="Content-Container-lvl6-Img">-->
                            <!--Container - Image/Title-->
                            <!--<a href="lifestyle.html"><img src="Images/nyc.png" style="width: 30vw; height: 35vw"></a>
                            <h2>Lifestyle</h2>
                        </div>
                    </div>

                    <div class="Content-Container-karla">-->
                        <!--Container - Image/article/tile-->
                        <!--<div id="Content-Container-lvl6-Img">-->
                            <!--Container - Image/Title-->
                            <!--<a href="Design.html"><img src="Images/FollowTheSun.png" style="width: 30vw; height: 35vw"></a>
                            <h2>Design</h2>
                        </div>
                    </div>
                </div>
        </section>-->




            <section id="bio">
                <h2>Who am I?</h2>

                <div class="projects-container">
                    <div class="project">
                        <h3>About Me:</h3>
                        <p>
                            I am a artist and UX/UI designer from Vancouver, BC.
                            Everyday I see an opportunity to find beauty in the natural world.
                            I help people envision their own perspective of beauty and create solutions through design.
                        </p>
                        <ul>
                            <li>
                                <b>UX/UI Designer</b> for indie games.
                            </li>
                            <li>
                                <b>Artist</b> self-taught with 3 decades of experience.
                            </li>

                        </ul>



                        <p>
                            I taught myself how to draw before I learned how to write my name. My childhood hobby evolved into a full time hobby as an adult,
                            manifesting into art shows, a prolific social media platform, and art displays in public spaces. My first medium was pen and paper but now I am teaching myself to use
                            digital programs such as Concepts, Figma, and Adobe Illustrator to diversify my art style.
                            I am also a dedicated ultra-marathoner and complete an average of 3-4 marathons or ultra-marathons a year.
                        </p>

                        <p>
                            I believe game development lives at the intersection of <b>business and art</b> - and I want to find a team that stands at that intersection with me.
                        </p>

                    </div>

                    <div class="project quarter-width">
                        <h3>Technical Skills:</h3>
                        <p>
                        </p><ul>
                            <li>HTML // CSS //</li>
                            <li>Figma // Concepts // Adobe Illustrator</li>
                            <li>Rapid Prototyping //</li>
                        </ul>
                        <p></p>
                    </div>
                    <div class="project quarter-width">
                        <h3>Values:</h3>
                        <p>
                        </p><ul>
                            <li>Staying true to your authentic self //</li>
                            <li>Continuing to learn and grow as a person //</li>
                            <li>Thinking outside of the box when it comes to problem solving //</li>
                            <li>Staying humble //</li>
                        </ul>
                        <p></p>
                    </div>
                </div>
            </section>



            <script src="script.js"></script>


            <footer id="contact">
                <div class="contact-text">
                    <p>Like what you see?</p>
                    <p>Contact me:</p>
                </div>

                <div class="contact-icons">
                    <!-- Email -->
                    <a href="mailto:pg27reid@vfs.com" aria-label="Email">
                        <i class="fa-solid fa-envelope"></i>
                    </a>
                    <!-- LinkedIn -->
                    <a href="https://www.linkedin.com/in/reid-gillis-b8105070/?originalSubdomain=ca" target="_blank" aria-label="LinkedIn">
                        <i class="fa-brands fa-linkedin"></i>
                    </a>
                </div>

                <p class="copyright">© Reid Gillis 2022–2025</p>
            </footer>


    </body></html>



